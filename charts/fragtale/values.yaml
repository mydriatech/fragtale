# Default values for ceso.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

app:
  backend: {}
    # Cassandra is the recommended database backend for linear scalability.
    #cassandra:
    #  # For Cassandra, the keyspace will be used for the common app keyspace
    #  # and as prefix for topic keyspaces.
    #  #
    #  # E.g. with the default, topic 'stuff' will have keyspace 'fragtale_stuff'
    #  # and the application itself will use the keyspace 'fragtale'.
    #  #
    #  # This allow external application to be granted permission to mine only
    #  # certain topics.
    #  keyspace: fragtale
    #  # The name of the secret with keys "username" and "password" defined
    #  # that will be used to access Cassandra.
    #  credentials: fragtale-k8cs-superuser
    #  hosts:
    #  - fragtale-k8cs-dc1-custom-svc.fragtale.svc.cluster.local:9042
    #  # The number of copies of the same data.
    #  # This cannot be changed later. 3 is sane choice for production.
    #  replicationFactor: 3
  integrity:
    # The shared secret protection algorithm OID.
    #
    #   HMAC_SHA3_256: 2.16.840.1.101.3.4.2.14
    #   HMAC_SHA3_384: 2.16.840.1.101.3.4.2.15
    #   HMAC_SHA3_512: 2.16.840.1.101.3.4.2.16
    #
    # Use the default unless you have a very good reason not to.
    oid: 2.16.840.1.101.3.4.2.16
    # Regenerate the secret during deploy.
    #
    # Increase this counter will trigger the regeneration.
    #
    # This will roll-over the current shared secret protection using the
    # algorithm specified in `oid` and rewrite the protection of internally
    # used binary digest trees.
    # 
    # Since the rewrite implies additional database operations, it should be
    # used sparsly
    #
    # After startup, the oldest node will log when this is safe to increase
    # again (e.g. the rewrite of protections is complete). This can take several
    # minutes. Triggering a regeneration before this will result in unverifiable
    # event integrity.
    #
    # When not using gitops, you could use BIND-style serial numbers YYYYMMddxx
    # to track when the last change was made (e.g. 2025070100).
    generation: 0
    # Time of events is taken from the local system time as long as it is within
    # an acceptable accurracy.
    #
    # Since the time of the event is part of the integrity protected data, this
    # allows you to trust that the event was recieved at the recorded point in
    # time Â± the tolerance configured here.
    #
    # This feature requires enabling the NTP side-car below.
    #
    # Tolerance is specified in microseconds and defaults to 0.45 seconds.
    # (Event time is correct at second granularity.)
    tolerance: 450000
  correlation:
    # The correlation token allows messages to be traced from request to result.
    #
    # Changing the OID of the correlation token's integrity protection will
    # break any correlation in progress.
    #
    # Use the default unless you have a very good reason not to.
    oid: 2.16.840.1.101.3.4.2.16

# Side-car NTP server configuration.
ntp:
  enabled: false
  image:
    repository: docker.io/cturra/ntp
    pullPolicy: Always
    tag: "latest"
  config:
    # A comma separated list of NTP upstream servers.
    servers: "time.cloudflare.com"
    # Network Time Security
    nts: true


# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: ghcr.io/mydriatech/fragtale
  #repository: localhost:32000/mydriatech/ceso
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# This is for the secretes for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

#This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# See also https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
  # Enable scraping of metrics by Prometheus
  #prometheus.io/scrape: "true"
  #prometheus.io/port: "8081"
  #prometheus.io/path: "/metrics"

# See also https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 8081

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  host: fragtale.local
  path: /
  pathType: ImplementationSpecific
  tls: {}
  #  secretName: fragtale-tls
  #  host: fragtale.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /health/live
    port: http
    # Defaults:
    #periodSeconds: 10
    #failureThreshold: 3
    #initialDelaySeconds: 0
readinessProbe:
  httpGet:
    path: /health/ready
    port: http
startupProbe:
  httpGet:
    path: /health/ready
    port: http
  failureThreshold: 120
  periodSeconds: 1

#This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 5
  #targetCPUUtilizationPercentage: 80
  #targetMemoryUtilizationPercentage: 80
  #additionalMetrics:
  #- type: Pods
  #  pods:
  #    metric:
  #      name: fragtale_mb_published_events_per_second
  #    target:
  #      type: AverageValue
  #      averageValue: 50
  #- type: Pods
  #  pods:
  #    metric:
  #      name: fragtale_mb_delivered_events_per_second
  #    target:
  #      type: AverageValue
  #      averageValue: 50

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}
