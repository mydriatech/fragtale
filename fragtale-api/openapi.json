{
  "openapi": "3.1.0",
  "info": {
    "title": "fragtale_api",
    "description": "Fragtale API",
    "license": {
      "name": "Apache-2.0 WITH AdditionRef-FWM-Exception-1.0.0",
      "identifier": "Apache-2.0 WITH AdditionRef-FWM-Exception-1.0.0"
    },
    "version": "0.0.0"
  },
  "paths": {
    "/health": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "This endpoint returns the combined status of initialized, readiness and\nliveness of a microservice.\n\nCorresponds to the Kubernetes readiness probe.",
        "operationId": "health",
        "responses": {
          "200": {
            "description": "Up",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "HTTP response body object for health requests. Only basic status is\nsupported.",
                  "required": [
                    "status"
                  ],
                  "properties": {
                    "status": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Undetermined"
          },
          "503": {
            "description": "Down"
          }
        }
      }
    },
    "/health/live": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "This endpoint returns the liveness of a microservice, or whether it\nencountered a bug or deadlock. If this check fails, the microservice is not\nrunning and can be stopped.\n\nThis endpoint corresponds to the Kubernetes liveness probe, which automatically\nrestarts the pod if the check fails.",
        "operationId": "health_live",
        "responses": {
          "200": {
            "description": "Up",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "HTTP response body object for health requests. Only basic status is\nsupported.",
                  "required": [
                    "status"
                  ],
                  "properties": {
                    "status": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Undetermined"
          },
          "503": {
            "description": "Down"
          }
        }
      }
    },
    "/health/ready": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "This endpoint returns the readiness of a microservice, or whether it is ready\nto process requests.\n\nCorresponds to the Kubernetes readiness probe.",
        "operationId": "health_ready",
        "responses": {
          "200": {
            "description": "Up",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "HTTP response body object for health requests. Only basic status is\nsupported.",
                  "required": [
                    "status"
                  ],
                  "properties": {
                    "status": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Undetermined"
          },
          "503": {
            "description": "Down"
          }
        }
      }
    },
    "/health/started": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "In MicroProfile Health 3.1 and later, you can use this endpoint to determine\nwhether your deployed applications are initialized, according to criteria that\nyou define.\n\nCorresponds to the Kubernetes startup probe.",
        "operationId": "health_started",
        "responses": {
          "200": {
            "description": "Up",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "HTTP response body object for health requests. Only basic status is\nsupported.",
                  "required": [
                    "status"
                  ],
                  "properties": {
                    "status": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Undetermined"
          },
          "503": {
            "description": "Down"
          }
        }
      }
    },
    "/metrics": {
      "get": {
        "tags": [
          "fragtale_metrics::http_metrics_resource"
        ],
        "summary": "Provides metrics in the `PrometheusText0.0.4` format.",
        "operationId": "metrics",
        "responses": {
          "200": {
            "description": "Ok. Sending PrometheusText0.0.4.",
            "content": {
              "text/plain; version=0.0.4": {}
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/topics/{topic_id}/confirm": {
      "get": {
        "tags": [
          "web_socket"
        ],
        "summary": "Open a WebSocket connection for sending event delivery confirmation messages.",
        "description": "Consumer identifier is derived from authentication.",
        "operationId": "confirm_event_delivery",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "description": "Topic identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "101": {
            "description": "Switching protocols to websocket."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/confirm/{unique_time}/{instance_id}": {
      "put": {
        "tags": [
          "http"
        ],
        "summary": "Confirm successful delivery of an event.",
        "description": "Consumer identifier is derived from authentication.",
        "operationId": "confirm_event_delivery",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "unique_time",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          },
          {
            "name": "instance_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully confirmed event delivery."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          },
          "403": {
            "description": "Forbidden: Authorization failure."
          },
          "500": {
            "description": "Internal server error."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/correlation/{correlation_token}": {
      "get": {
        "tags": [
          "http"
        ],
        "summary": "Retrieve event document related to another event.",
        "description": "This enables treating the API as an RPC-style REST API with a PRG twist,\npubishing an event can be seen as a request and following the link will\nreturn an event from a different topic as a result as long as this happens\nwithin a reasonable timeout.\n\nConsumer identifier is derived from authentication.",
        "operationId": "by_topic_and_correlation_token",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "correlation_token",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Event document is delivered in the response body.",
            "content": {
              "application/json": {}
            }
          },
          "204": {
            "description": "No correlated event document has appeared within the timeout."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          },
          "403": {
            "description": "Forbidden: Authorization failure."
          },
          "500": {
            "description": "Internal server error."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/description": {
      "put": {
        "tags": [
          "http"
        ],
        "summary": "Upsert topic's event description.",
        "description": "Use this call to specify an even document schema that will be used for\nvalidation or extractors to index values in the event document to enable\nqueries.\n\nThe validation and extraction operates on write (publishing of new events)\nand has no effect on historic events.\n\nPublisher identifier is derived from authentication.",
        "operationId": "topic_event_description_upsert",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Specify handling of events when published to a topic.\n\nContains event schema, schema versioning and indexed document value\nextraction.",
                "required": [
                  "version"
                ],
                "properties": {
                  "event_schema": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "object",
                        "description": "The even schema for each topic is an optional feature to ensure that\ndocuments are well formed.\n\nSchemas must be self-contained.",
                        "required": [
                          "schema_id",
                          "schema_type",
                          "schema_data"
                        ],
                        "properties": {
                          "schema_data": {
                            "type": "string"
                          },
                          "schema_id": {
                            "type": "string"
                          },
                          "schema_type": {
                            "type": "string"
                          }
                        }
                      }
                    ],
                    "description": "Optional event schema used to validate event documents.\n\nSee [Self::get_event_schema]."
                  },
                  "extractors": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "type": "object",
                      "description": "Description of what and how to extract values from event documents.",
                      "required": [
                        "result_name",
                        "result_type",
                        "extraction_type",
                        "extraction_path"
                      ],
                      "properties": {
                        "extraction_path": {
                          "type": "string",
                          "description": "When extraction_type is \"jsonpointer\", this points to the value to extract.\nE.g. \"/property-of-document-root\"."
                        },
                        "extraction_type": {
                          "type": "string",
                          "description": "Type of extraction: \"jsonpointer\""
                        },
                        "result_name": {
                          "type": "string",
                          "description": "Name of index key."
                        },
                        "result_type": {
                          "type": "string",
                          "description": "One of a subset of data types defined by Cassandra.\n\nExample: \"text\" or \"bigint\""
                        }
                      }
                    },
                    "description": "Optional extractors for indexing document values.\n\nSee [Self::get_extractors]."
                  },
                  "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The current version.\n\nSee [Self::get_version].",
                    "minimum": 0
                  },
                  "version_min": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "int64",
                    "description": "The minumum supported version that is allowed to be used once this\nversion is en effect.\n\nSee [Self::get_version_min].",
                    "minimum": 0
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successfully updated topic's event description."
          },
          "400": {
            "description": "Bad Request."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          },
          "403": {
            "description": "Forbidden: Authorization failure."
          },
          "500": {
            "description": "Internal server error."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/events": {
      "get": {
        "tags": [
          "web_socket"
        ],
        "summary": "Open a WebSocket connection for publishing events.",
        "description": "Publisher identifier is derived from authentication.",
        "operationId": "publish_event_to_topic",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "description": "Topic identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "101": {
            "description": "Switching protocols to websocket."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      },
      "put": {
        "tags": [
          "http"
        ],
        "summary": "Publish event document.",
        "description": "Please note the `correlation-token` and `location` header if you need to\nfind an event from a different topic that is the result of processing this event.\n\nPublisher identifier is derived from authentication.",
        "operationId": "publish_event_to_topic",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "description": "Topic identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "priority",
            "in": "query",
            "description": "Importance of the published event. 0-100 where 100 is most important.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 0
            }
          },
          {
            "name": "version",
            "in": "query",
            "description": "Event Descriptor SemVer the event is expected to comply to. (E.g. major.minor).",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "target",
            "in": "query",
            "description": "Expected target topic of correlated event processing.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Ok. Successfully published event and returning response of correlated request.",
            "content": {
              "application/json": {}
            }
          },
          "204": {
            "description": "No content. Successfully published event.",
            "headers": {
              "correlation-token": {
                "schema": {
                  "type": "string"
                },
                "description": "Opaque token that can be used to correlate events."
              }
            }
          },
          "303": {
            "description": "See other. Correlated result did not appear before the timeout. Poll linked resource to keep trying.",
            "links": {
              "Location": {
                "operation_id": "by_topic_and_correlation_token",
                "parameters": {
                  "correlation_token": "string",
                  "topic_id": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          },
          "403": {
            "description": "Forbidden: Authorization failure."
          },
          "500": {
            "description": "Internal server error."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/events/by_event_id/{event_id}": {
      "get": {
        "tags": [
          "http"
        ],
        "summary": "Retrieve an event document by its identifier.",
        "description": "Consumer identifier is derived from authentication.",
        "operationId": "event_by_topic_and_id",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "description": "Topic identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "index_name",
            "in": "path",
            "description": "The name of the index.",
            "required": true
          },
          {
            "name": "index_key",
            "in": "path",
            "description": "The lookup key to use when searching the index.",
            "required": true
          },
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Return the event document.",
            "content": {
              "application/json": {}
            }
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          },
          "403": {
            "description": "Forbidden: Authorization failure."
          },
          "404": {
            "description": "No event document with the event identifier was found."
          },
          "500": {
            "description": "Internal server error."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/events/ids_by_index/{index_name}/{index_key}": {
      "get": {
        "tags": [
          "http"
        ],
        "summary": "Query index for event identifiers.",
        "description": "The index must have been created with an extractor in event descriptor\nbefore an event was published for the value to be indexed.\n\nConsumer identifier is derived from authentication.",
        "operationId": "event_ids_by_topic_and_index",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "description": "Topic identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "index_name",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "index_key",
            "in": "path",
            "description": "The lookup key to use when searching the index.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Array of matching event identifiers.",
            "content": {
              "application/json": {}
            }
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          },
          "403": {
            "description": "Forbidden: Authorization failure."
          },
          "500": {
            "description": "Internal server error."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/next": {
      "get": {
        "tags": [
          "http"
        ],
        "summary": "Poll for new events.",
        "description": "Consumer identifier is derived from authentication.",
        "operationId": "next_event_by_topic_and_consumer",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "description": "Topic identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "from",
            "in": "query",
            "description": "Only consider events newer than this in epoch milliseconds.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          },
          {
            "name": "version",
            "in": "query",
            "description": "Event Descriptor SemVer that the client prefers (major.minor).",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A new event is delivered in the response body.",
            "links": {
              "Location": {
                "operation_id": "confirm_event_delivery",
                "parameters": {
                  "correlation_token": "string",
                  "instance_id": "number",
                  "topic_id": "string",
                  "unique_time": "number"
                }
              }
            }
          },
          "204": {
            "description": "No new event was found."
          },
          "400": {
            "description": "Bad Request."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          },
          "403": {
            "description": "Forbidden: Authorization failure."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    },
    "/topics/{topic_id}/subscribe": {
      "get": {
        "tags": [
          "web_socket"
        ],
        "summary": "Open a WebSocket connection for subscribing to new events.",
        "description": "Consumer identifier is derived from authentication.",
        "operationId": "subscribe_to_topic",
        "parameters": [
          {
            "name": "topic_id",
            "in": "path",
            "description": "Topic identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "from",
            "in": "query",
            "description": "Only consider events newer than this in epoch milliseconds.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          },
          {
            "name": "version",
            "in": "query",
            "description": "Event Descriptor SemVer that the client prefers (major.minor).",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "101": {
            "description": "Switching protocols to websocket."
          },
          "400": {
            "description": "Bad Request."
          },
          "401": {
            "description": "Unauthorized: Authentication failure."
          }
        },
        "security": [
          {
            "bearer_auth": []
          }
        ]
      }
    }
  },
  "components": {
    "securitySchemes": {
      "bearer_auth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    }
  }
}